### about docs
- go1.24.0 버전 기준으로 작성

### [A Tour of Go](https://go.dev/tour/list)
- golang은 package로 구성되며 golang으로 개발된 프로그램은 main package을 통해 실행된다.
- `import` 키워드를 사용해 package가 속한 경로를 import할 수 있다. 편의를 위해 import 경로의 마지막 구성 요소를 package 이름으로 사용하는 것이 일반적이다.
- `import` 키워드를 여러 번 사용해 여러 package를 import할 수도 있지만 import (...)와 같이 사용하는 것을 권장한다.
- package 내에서 대문자로 시작되는 이름을 갖는 경우 해당 package 밖에서도 참조가 가능하며 이를 exported name이라고 한다. 반대로 소문자로 시작되는 이름을 갖는 경우 package 내부에서만 참조가 가능하다.
- 함수의 반환 값에 이름을 지정하는 경우 함수의 최상단에서 정의된 변수로 취급된다. 함수에서는 `return` 키워드만 사용해도 반환이된다. `return` 키워드를 생략하는 것은 불가능하다. 이를 naked return이라고 부르며 짧은 길이의 함수에서만 사용하는 것을 권장한다.
- `var` 키워드를 사용해 변수를 선언할 수 있다. 변수 선언 시 초기화도 수행하면 변수의 타입을 생략할 수 있다. 
- 함수 내부에서는 `:=` short assignment statement만 이용해 변수를 선언 및 초기화할 수 있다. 함수 외부에서는 항상 키워드로 시작해야 하기 때문에 사용할 수 없다.
- 변수 선언 시 초기화를 하지 않으면 zero value가 할당된다. 숫자 타입일 경우 0, boolean 타입일 경우 false, string 타입일 경우 ""
- 묵시적 형변환이 불가능하며 항상 `T(v)` 표현식을 사용해 타입 변환을 수행해야 한다.
- 변수 선언 시 타입을 지정하지 않는 경우 변수의 타입은 초기화 값으로부터 추론된다. 초기화 값이 명시적인 타입을 갖는 경우 변수는 동일한 타입을 갖는다. 하지만 타입이 없는 숫자 상수의 경우 정밀도에 따라 `int`, `float64`, `complex128` 타입으로 추른된다.
- `const` 키워드를 사용해 상수를 선언할 수 있다. 상수는 문자, 문자열, boolean, 숫자 타입일 수 있다(`:=` short assignment statement는 변수 선언시 사용되기 때문에 상수에 대해서는 사용할 수 없다).
- 타입이 지정되지 않은 상수는 사용되는 문맥에 따라 필요한 타입을 갖게된다.
- 반복문을 위해 `for` 키워드만 지원한다. ()로 감싸지 않아도 되지만 블럭에는 {}가 항상 필요하다.
- `if`문도 `for`문과 동일하게 ()로 감싸지 않아도 되지만 블럭에는 {}가 항상 필요하다. `if`문에 short assignment statement를 사용할 수 있으며 해당 변수는 `else if`, `else if` 블럭에서도 사용할 수 있다.
- `switch`문에는 `break` 문을 명시할 필요없다. 조건을 생략하는 경우 `switch true`와 동일하다.
- `defer`문은 함수의 반환까지 함수의 실행을 연기한다. 함수의 매개변수는 `defer` 문에서 결정되지만 호출은 지연된다. 지연된 함수는 stack에 push되며 LIFO로 실행된다.
- `*T`는 포인터 타입으로 기본 값은 `nil`이다. `&` 연산자는 피연산자의 포인터를 생성한다. `*` 연산자는 포인터가 가리키는 값을 나타낸다. 포인터에 대한 산술 연산자는 없다.
- struct는 필드의 집합으로 각 필드는 .을 이용해 접근한다. struct pointer의 경우 `(*p).X`을 통해 접근 가능하지만 번거롭기 때문에 `p.X`와 같이 접근하는 것을 허용한다. `type struct 이름{...}` 문을 이용해 struct 타입을 정의할 수 있다.
- struct 리터럴은 순서대로 값을 나열하거나 `Name:`처럼 필드의 이름과 값을 순서 상관없이 나열해 표현할 수 있다. 
- `[n]T` 타입은 배열이다. 배열의 크기는 배열 타입의 일부기 때문에 크기를 조정할 수 없다.
- `[]T` 타입은 슬라이스로 동적으로 크기 조절이 가능하며 배열보다 더 일반적으로 사용한다. 슬라이스는 내부적으로 배열을 가리키는 포인터, 길이, 용량 정보를 저장하며 기본 값은 `nil`이다. 배열 또는 슬라이스 변수 a에 대해 `a[low:high]`의 표현식을 사용해 슬라이싱해 슬라이스 값을 얻을 수 있다.
- 슬라이스의 길이는 슬라이스를 통해 접근할 수 있는 요소의 길이를 나타내며 용량은 실제 슬라이스가 참조가 있는 배열 길이를 나타낸다(슬라이스가 가리키는 첫 인덱스부터 배열의 마지막 인덱스까지). 슬라이스의 길이는 `len(s)`, 용량은 `cap(s)` 내장 함수를 통해 얻을 수 있다.
- `make([]T, len, (cap))` 함수를 사용해 zero value를 갖는 슬라이스 값을 생성할 수 있다.
- `func append(s []T, vs ...T) []T` 함수를 사용해 슬라이스 마지막 인덱스 뒤에 값을 계속 추가할 수 있다. 기존 배열의 크기가 작으면 크기가 더 큰 배열을 생성 및 할당한다.
- `for i, v := range sli {}`와 같은 표현식을 사용해 slice에 대해 반복문을 사용할 수 있다. 변수 i는 인덱스, v는 해당 인덱스의 복사된 값을 갖는다. `_` 표현식을 사용해 할당을 하지 않을 수 있으며 v는 생략할 수도 있다.
- `map[K]V` 타입은 맵이다. 기본 값은 nil이며 리터럴은 struct와 다르게 key를 생략할 수 없다. `m[key]` 표현식을 사용해 map에 저장된 요소에 접근할 수 있다. `elem = m[key]` 표현식은 변수 m에 key가 없을 경우 오류가 발생한다. 반면 `elem, ok = m[key]` 표현식은 변수 m이 key가 있으면 ok 변수에 true, 없다면 false 값을 갖는다. key가 없는 경우 elem 변수에 zero value가 할당된다. `delete(m, key)` 함수를 사용해 맵 변수 m에서 key를 삭제할 수 있다.